#!/usr/bin/python
# This python script identifies beamlets defined by intervals between lines in (z,gamma), 
# converts beam output from VSim (as supplied by Georg Wittig) to SI units  
# and generates beamlet files for input to Puffin. The beamlet files are generated by taking a
# small window of width Dz and calculating the mean and std. dev. of gamma, x, y, px, py,...
# of the electrons in the window. The window position is scanned over z to calculate these
# parameters across the beams. This information is then interpolated to a number of points 
# per wavelength (pPerLam) for input into Puffin which allocates new particle distributions 
# with these parameters.
  
import sys,os,sdds,math
 
genPuffin = 1                # Generate Puffin input files only if genPuffin==1

# Partition lines in (gamma,z) defining beamlets
# Start with line for highest gamma by defining 2 points (z1,g1) and (z2,g2)
# Subsequent lines for lower gamma values - lines cannot cross
# Format: zpts = (z1,z2,...)  !! The first line is then defined by the points:
#         gpts = (g1,g2,...)  !! (z1,g1) and (z2,g2)
# zpts    = [1.5e-5, 1e-5, 1.5e-05, 8e-6, 1e-05, 5e-6, 5e-6, 0]
# gpts    = [350,    400,  245,     326,  229,    275,  100, 200]     

zpts    = [0,7e-6, 0,7e-6]
gpts    = [3000, 3100, 300, 350]

# Physical constants
e      =  1.602e-19          # Electron charge magnitude
me     =  9.11e-31           # Electron rest mass
c      =  3e+08              # Speed of light
e0     =  8.854e-12          # Permitivity of free space

# Parameters
aw       = 1.1985            # RMS undulator parameter
lambdaw  = 0.0153            # Undulator period (m)
f        = math.sqrt(2)      # Focussing factor: f=sqrt(2) for natural undulator focussing
R56      = 0                 # R56 factor applied to the jth particle as: Dz_j = R56 * (gamma_j-<gamma>)/<gamma>

Dz       = 0.7e-6              # Interval in z for calculating running statistical values  
Dt       = Dz/c              # Interval in t for calculating running statistical values                  
pPerLam  = 20                # Interpolation points per resonant wavelength of each beamlet
iorder   = 1                 # Interpolation order
filz2    = 1                 # If ==1 select range of z2 to [z2main,z2max] for Puffin file 
z2min    = 0
z2max    = 250    


numb     = len(zpts)/2-1     # Number of beamlets defined by the partition lines
kw       = 2*math.pi/lambdaw # k_w

if len(sys.argv)==2:
   fname=sys.argv[1]
   print 'Processing file:', fname
else:
   print 'Usage: hdf2puff <file name> \n'
   sys.exit(1)   

# Base file name
fbase  = (fname.split('.')[0]).strip()

fdissi = fbase+'.dissi'; # SDDS file containing required VSim data in SI units
#fintp  = fbase+'.intp';  # SDDS Interpolated data in SI units
#fpuf   = fbase+'.puf';   # SDDS Puffin data in scaled units
#fpufil = fbase+'.pufil'; # SDDS Puffin data over filtered range [z2min,z2max] in scaled units 
# Other files are generated of the form <fbase>_?.

#############################################################################################
# Read hdf5 file & convert into SDDS format retaining original SI units,
# calculate number of e per macroparticle ne, and change px etc to values per electron,
# then gamma, xpx etc, and sort particles by t, and write SDDS output to file <fbase>.dissi
#############################################################################################

# SDDS symbols for variables
xSym     = "'x'"
pxSym    = "'p$bx$n'"
ySym     = "'y'"
pySym    = "'p$by$n'"
tSym     = "'t'"
zSym     = "'z'"
pzSym    = "'p$bz$n'"
mSym     = "'m'"
mUSym    = "'kg'"
qpSym    = "'Qp'"
qSym     = "'Q'"
neSym    = "'n$be$n'"
lenSym   = "'m'"
timSym   = "'s'"
chaSym   = "'C'"
momSym   = "'MeV/c'"
momSISym = "'kg m/s'"
gammaSym = "'$gg'"
TrSym    = "'Tr'"
WSym     = "'W'"

# SDDS scripts for calculating variables
# The columns are read in from hdf5 into columns named D1-D8
# The VSim variables are converted from x to z as direction of propagation
# Quantities are per electron in SI units 
xCalc       = "'D3 -1 *'"                                  # x-coordinate   = VSim z*(-1)
yCalc       = "'D2'"                                       # y-coordinate   = VSim y 
zCalc       = "'D1'"                                       # z-coordinate   = VSim x
pxCalc      = "'D6 -1 * m *'"                              # px-coordinate  = VSim pz*(-1)*me
pyCalc      = "'D5 m *'"                                   # py-coordinate  = VSim py*me
pzCalc      = "'D4 m *'"                                   # pz-coordinate  = VSim px*me
TrCalc      = "'D7'"                                       # Tracking factor 
WCalc       = "'D8'"                                       # Weight factor
zReCalc     = "'z zMin -'"                                 # Redefine minimum particle position to be z=0
zDCalc     = "'z gamma gammaAvgG - gammaAvgG / R56 * +'"   # Apply dispersion to z
gammaCalc   = "'px sqr py sqr + pz sqr + m "\
               +str(c)+" * sqr / 1 + sqrt'"                # Calculate gamma = sqrt(1+ (p/mc)^2)
tCalc       = "'zMax z - gamma * pz / m *'"                # Calculate t of particles t=(zMax-z)/v_z
qpCalc       = "'charge -1 *'"                             # Redefine VSim particle q to be the charge magnitude
mCalc       = "'mass'"                                     # VSim particle mass
xpCalc      = "'px pz /'"                                  # Calculate dx/dz = px/pz
ypCalc      = "'py pz /'"                                  # Calculate dy/dz = py/pz
neCalc      = "'numPtclsInMacro'"                          # Number of e per macroparticle
qCalc       = "'ne qp * W *'"                              # Charge of each macroparticle
xpxCalc     = "'x px *'"                                   # Calculate x*px
ypyCalc     = "'y py *'"                                   # Calculate y*py
os.system("hdf2sdds %s -pipe=output\
         | sddsprocess -pipe\
           -define=parameter,qp,%s,symbol=%s,units=%s\
           -define=parameter,m,%s,symbol=%s,units=%s\
           -define=parameter,ne,%s,symbol=%s\
           -define=column,x,%s,symbol=%s,units=%s\
           -define=column,y,%s,symbol=%s,units=%s\
           -define=column,z,%s,symbol=%s,units=%s\
           -define=column,px,%s,symbol=%s,units=%s\
           -define=column,py,%s,symbol=%s,units=%s\
           -define=column,pz,%s,symbol=%s,units=%s\
           -define=column,Tr,%s,symbol=%s\
           -define=column,W,%s,symbol=%s\
      	   -define=column,xpx,%s\
      	   -define=column,ypy,%s\
           -define=column,gamma,%s,symbol=%s\
           -define=column,q,%s,symbol=%s\
           -process=gamma,average,gammaAvgG,weightBy=q\
           -process=z,minimum,zMin\
           -redefine=column,z,%s\
           -process=z,maximum,zMax\
           -define=column,t,%s\
         | sddssort -pipe -column=t\
         | sddsprocess -pipe=input %s\
           -retain=parameters,qp,m,ne,gammaAvgG\
           -retain=columns,x,y,z,px,py,pz,xpx,ypy,gamma,q,z,t"\
           %(fname,\
             qpCalc,qpSym,chaSym,mCalc,mSym,mUSym,neCalc,neSym,\
             xCalc,xSym,lenSym,yCalc,ySym,lenSym,zCalc,zSym,lenSym,\
             pxCalc,pxSym,momSym,pyCalc,pySym,momSym,pzCalc,pzSym,momSym,\
             TrCalc,TrSym,WCalc,WSym,\
             xpxCalc,ypyCalc,gammaCalc,gammaSym,qCalc,qSym,zReCalc,tCalc,\
             fdissi))
print 'Original data in SI to                      :', fdissi

# Plot output before and after dispersion to enable partition lines that define beamlets to be chosen  
os.system("sddsplot -columnName=z,gamma %s -graphic=dot" %fdissi)
# Apply R56 to full beam
os.system("sddsprocess %s\
           -define=parameter,R56,%e\
           -redefine=column,z,%s,symbol=%s,units=%s"\
           %(fdissi,\
             R56,zDCalc,zSym,lenSym))
os.system("sddsplot -columnName=z,gamma %s -graphic=dot" %fdissi)

if genPuffin!=1:
   sys.exit("No Puffin output will be generated unless genPuffin==1")
##############################################################################################################
# Calculate 'running' statistical values of variables about a window of width Dt for each of the beamlets.
# This smooths out the noisy data from the 'course' macroparticle distribution.
# This smoothed data is then interpolated onto the (usually larger) number of sample points in t.
# Various data (Current, peak current, emittance etc) are then calculated and beamlet-averages taken (avgName)
###############################################################################################################

# SDDS symbols for variables
ISym            = "'I'"
ISISym          = "'A'"
betazSym        = "'$gb$r$bz$n'"
neSym           = "'n$be$n'"
neSISym         = "'s$a-1$n'"
p2Sym           = "'p$b2$n'"
xrStDevSym       = "'$gs$r$bxr'"
yrStDevSym       = "'$gs$r$byr'"
rStDevSym       = "'$gs$r$br'"
emitxnrmsSym    = "'$ge$r$bxn-rms'"
emitynrmsSym    = "'$ge$r$byn-rms'"
emitnrmsSym     = "'$ge$r$bn-rms'"
emitUnit        = "'m rad'"

# SDDS calculation of variables
lambdarLCalc     = "'lambdaw 2 / avgGamma sqr / 1 aw sqr + *'"                         # Resonant wavelength for local beamlet
iptsCalc        = "'tMax tMin - c * lambdarL / "+str(pPerLam)+" * int'"                # Number of interpolation points
# See Floettmann, PRST-AB, 6, 034202 (2003) for these normalised rms emittance definitions
emitxnrmsCalc   = "'xStDev sqr pxStDev sqr * xpxStDev 4 pow - sqrt me / c /'"          # e_xn,rms
emitynrmsCalc   = "'yStDev sqr pyStDev sqr * ypyStDev 4 pow - sqrt me / c /'"          # e_yn,rms
emitnrmsCalc    = "'emitxnrms sqr emitynrms sqr + sqrt'"                               # e_n,rms
ICalc           = "'qSum Dt /'"                                                        # Current I = Q/Dt
neCalc          = "'I "+str(e)+" /'"                                                   # Rate of e flow = I/e
IoACalc         = "'I 2 "+str(math.pi)+" * avgStDevr sqr * /'"                         # I/(2 pi <sigma_r>^2)
betazCalc       = "'pzMean gamma / me / c /'"                                          # beta_z=v_z/c
p2Calc          = "'1 betaz - betaz / eta /'"                                          # p_2 - Puffin variable
# Assume beam pre-matched to undulator focussing: sigma_r = sqrt(f*epsilon_n/a_w*k_w)
# xrStDevCalc      = "'"+str(f)+" emitxnrms * aw / "+str(kw)+" / sqrt'"
# yrStDevCalc      = "'"+str(f)+" emitynrms * aw / "+str(kw)+" / sqrt'"
rStDevCalc      = "'xStDev sqr yStDev sqr + sqrt'"    #  for no beam matching
# rStDevCalc      = "'"+str(f)+" emitnrms * aw / "+str(kw)+" / sqrt'"    #  for beam matching

guCalc          = "'z z1u - mu * g1u +'"                                               # Beamlet upper limit of gamma(z)
glCalc          = "'z z1l - ml * g1l +'"                                               # Beamlet lower limit of gamma(z)
gammaTest       = "'gamma gu < pop pop gamma gl > pop pop &&'"                         # Filter test for gl<gamma<gu 

fin = fdissi               # Input file in SI
finb,fine = fin.split(".") # Split into base name and extension
flist     = ""             # Initialise list of interpolated filenames for each beamlet

# Loop over SI input file and filter out the different beamlets writing a separate numbered SI output file for each beamlet
# Then write out interpolated  
for i in range(0,numb):
    # Define the upper partition line
    z1u   = zpts[2*i]                        # z of point 1
    g1u   = gpts[2*i]                        # gamma of point 1
    z2u   = zpts[2*i+1]                      # z of point 2
    g2u   = gpts[2*i+1]                      # gamma of point 2
    mu    = (g2u-g1u)/(z2u-z1u)              # gradient of upper line
    # Define the lower partition line
    z1l   = zpts[2*i+2]                      # z of point 1
    g1l   = gpts[2*i+2]                      # gamma of point 1
    z2l   = zpts[2*i+3]                      # z of point 2
    g2l   = gpts[2*i+3]                      # gamma of point 2
    ml    = (g2l-g1l)/(z2l-z1l)              # gradient of lower line
    print 'Filtering between:' 
    print 'Upper line between points: ('+str(z1u)+','+str(g1u)+') and ('+str(z2u)+','+str(g2u)+') and'
    print 'Lower line between points: ('+str(z1l)+','+str(g1l)+') and ('+str(z2l)+','+str(g2l)+').'

    print 'div by zero yet?'
  
    fblet = finb+"_"+str(i+1)+"."+fine       # Beamlet file name: <baseName>_i.<extension>
    # Filter out the beamlet macroparticles defined by gamma range [gmin,gmax]
    # Calculate the number of interpolation points based upon number of points per wavelength pPerLam
  
    print 'div by zero yet?'

    os.system("sddsprocess %s %s\
               -define=parameter,e,%e\
               -define=parameter,me,%e\
               -define=parameter,c,%e\
               -define=parameter,e0,%e\
               -define=parameter,aw,%e\
               -define=parameter,lambdaw,%e\
               -define=parameter,g1u,%e\
               -define=parameter,g1l,%e\
               -define=parameter,z1u,%e\
               -define=parameter,z1l,%e\
               -define=parameter,mu,%e\
               -define=parameter,ml,%e\
               -define=column,gu,%s\
               -define=column,gl,%s\
               -test=column,%s\
               -process=gamma,average,avgGamma,weightBy=q\
               -define=parameter,lambdarL,%s\
               -process=t,minimum,tMin\
               -process=t,maximum,tMax\
               -define=parameter,ipts,%s,type=long"\
              %(fin,fblet,\
                e,me,c,e0,aw,lambdaw,\
                g1u,g1l,z1u,z1l,mu,ml,guCalc,glCalc,gammaTest,\
                lambdarLCalc,iptsCalc))

    print fin
    print 'What\'s wrong?'
    print 'doing section ' + str(i+1)
    print 'fblet is ' + str(fblet)

    # Write resonant wavelength lambda_r, and number of interpolation points for the beamlet  
    print 'Resonant wavelength for beamlet '+str(i+1)+'  = '+str(sdds.getParameter(fblet,'lambdarL'))
    os.system("sddsprocess %s -noWarnings\
               -delete=parameter,e,me,c,e0,aw,lambdaw,avgGamma,tMin,tMax,zMin,zMax" %fblet)
    ipts = int(sdds.getParameter(fblet,'ipts'))
    print 'Interpolation points for beamlet '+str(i+1)+' = '+str(ipts)

    fintp  = fbase+"_"+str(i+1)+".intp";    # Filename for interpolated beamlet data in SI units: <baseName>_i.intp
    flist  = flist+" "+fintp                # Add this to list of interpolated beamlet filenames 

    # Calculate running statistics, interpolate variables onto grid and calculate relevant 
    # parameters from the interpolated variables for each beamlet and output to file of interpolated data
    os.system("sddsrunstats %s -pipe=output\
           -window=column=t,width=%e\
           -mean=x,px,xp,xpx,y,py,yp,ypy,t,pz,gamma,z\
           -standardDeviation=x,px,xpx,y,py,ypy,t,pz,gamma,z\
           -sum=q\
         | sddsinterp -pipe\
           -order=%d\
           -sequence=%d\
           -columns=tMean,zMean,gammaMean,gammaStDev,pzMean,pzStDev,xMean,xStDev,pxMean,pxStDev,xpxMean,xpxStDev,yMean,yStDev,pyMean,pyStDev,ypyMean,ypyStDev,qSum\
         | sddsprocess -pipe=input %s\
           -define=parameter,Dt,%e\
           -define=parameter,e,%e\
           -define=parameter,me,%e\
           -define=parameter,c,%e\
           -define=parameter,e0,%e\
           -define=parameter,aw,%e\
           -define=parameter,lambdaw,%e\
           -define=column,emitxnrms,%s,symbol=%s,units=%s\
           -define=column,emitynrms,%s,symbol=%s,units=%s\
           -define=column,emitnrms,%s,symbol=%s,units=%s\
           -define=column,I,%s,symbol=%s,units=%s\
           -define=column,ne,%s,symbol=%s,units=%s\
           -define=column,rStDev,%s,symbol=%s,units=%s\
           -process=gammaMean,average,avgGamma,weightBy=I\
           -process=gammaMean,minimum,gammaMeanMin\
           -process=gammaStDev,average,avgStDevGamma,weightBy=I\
           -process=xMean,average,avgx,weightBy=I\
           -process=xStDev,average,avgStDevx,weightBy=I\
           -process=yMean,average,avgy,weightBy=I\
           -process=yStDev,average,avgStDevy,weightBy=I\
           -process=rStDev,average,avgStDevr,weightBy=I\
           -process=pxMean,average,avgpx,weightBy=I\
           -process=pxStDev,average,avgStDevpx,weightBy=I\
           -process=pyMean,average,avgpy,weightBy=I\
           -process=pyStDev,average,avgStDevpy,weightBy=I\
           -process=pzMean,average,avgpz,weightBy=I\
           -process=pzStDev,average,avgStDevpz,weightBy=I\
           -define=column,IoA,%s\
           -process=I,maximum,Ipk\
           -process=ne,maximum,neMax\
           -process=IoA,maximum,IoAmax"\
           %(fblet,Dt,\
             iorder,ipts,\
             fintp,Dt,e,me,c,e0,aw,lambdaw,\
             emitxnrmsCalc,emitxnrmsSym,emitUnit,\
             emitynrmsCalc,emitynrmsSym,emitUnit,\
             emitnrmsCalc,emitnrmsSym,emitUnit,
             ICalc,ISym,ISISym,\
             neCalc,neSym,neSISym,\
             rStDevCalc,rStDevSym,lenSym,\
             IoACalc))
    print "Interpolated (matched) data for beamlet "+str(i+1)+" to:", fintp

#######################################################################################################
# From interpolated data calculate Puffin parameters required for 1D input file
# Use the minimum energy and the highest current density (I/A) from ALL beamlets in definition
# of a global rho parameter to all beamlets 
#######################################################################################################
    
# Find maximum of Current density, electron rate and minimum of <gamma> for all beamlets 
ftmp  = fbase+".tmp";                               # Temporary file 
# Take the current, density and gamma for each of the beamlets and find global extrema
os.system("sddscombine %s -pipe=output -collapse\
        |  sddsprocess -pipe=input %s\
             -process=IoAmax,maximum,IoAglobalMax\
             -process=neMax,maximum,neGlobalMax\
             -process=gammaMeanMin,minimum,gammaMeanGlobalMin"\
           %(flist,ftmp))
IoAglobalMax       = float(sdds.getParameter(ftmp,'IoAglobalMax'))
neGlobalMax        = float(sdds.getParameter(ftmp,'neGlobalMax'))
gammaMeanGlobalMin = float(sdds.getParameter(ftmp,'gammaMeanGlobalMin'))

# SDDS symbols for variables for Puffin data 
z2Sym          = "'z$h$h$u$u_$v$v$n$b2'"
n_barSym       = "'n$h$h$u$u_$v$v$n$b$sbb$e'"
gammaSym       = "'$gg'"
sig_gammaSym   = "'$gs$bg$n'"
sig_pSym       = "'$gs$r$bp$n'"
sg_emitSym     = "'$gs$bge$n'"
sg_totSym      = "'$gs$bg$rTot$n'"
x_barSym       = "'x$h$h$u$u_$v$v$n'"
y_barSym       = "'y$h$h$u$u_$v$v$n'"
sig_x_barSym   = "'$gs$r$h$h$u$u_$v$v$n$bx$n'"
sig_y_barSym   = "'$gs$r$h$h$u$u_$v$v$n$by$n'"
sig_r_barSym   = "'$gs$r$br'"
px_barSym      = "'p$h$h$u$u_$v$v$n$bx'"
py_barSym      = "'p$h$h$u$u_$v$v$n$by'"
sig_px_barSym  = "'$gs$r$h$h$u$u_$v$v$n$bpx$n'"
sig_py_barSym  = "'$gs$r$h$h$u$u_$v$v$n$bpy$n'"
Z_R_barSym     = "'z$h$h$u$u_$v$v$n$bR$n'"
k_beta_barSym  = "'k$h$h$u$u_$v$v$n$b$gb$r$n'"
emit_barSym    = "'$ge$h$h$u$u_$v$v$n$r'"
match_testSym  = "'$ge$h$h$u$u_$v$v$n$r / 2 k$h$h$u$u_$v$v$n$b$gb$r$n z$h$h$u$u_$v$v$n$bR$n'"

# SDDS calculation of Puffin variables
lambdarCalc    = "'lambdaw 2 / gammaMeanGlobalMin sqr / 1 aw sqr + *'"      # Global resonant wavelength for minimum beamlet energy (maximum resonant wavelength)
rhoCalc        = "'e 16 / e0 / me / c 3 pow / aw sqr * "+str(kw)+" sqr / "\
                 +"IoAglobalMax * 0.3333 pow gammaMeanGlobalMin /'"         # Global rho using minimum beamlet energy and maximum beamlet current density
lgCalc         = "'lambdaw 4 / "+str(math.pi)+" / rho /'"                   # Global gain length
lcCalc         = "'lambdar 4 / "+str(math.pi)+" / rho /'"                   # Global cooperation length
rhoLCalc       = "'e 16 / e0 / me / c 3 pow / aw sqr * "+str(kw)+" sqr / "\
                 +"IoAmax * 0.3333 pow avgGamma /'"                         # Local rho using mean beamlet energy and maximum beamlet current density
lgLCalc        = "'lambdaw 4 / "+str(math.pi)+" / rhoL /'"                  # Local beamlet gain length
lcLCalc        = "'lambdarL 4 / "+str(math.pi)+" / rhoL /'"                 # Local beamlet cooperation length
etaCalc        = "'lambdar lambdaw /'"                                      # eta - uses maximum resonant wavelength
#z2Calc         = "'tMean tmin - c * lc /'"
z2Calc         = "'tMean c * lc /'"                                         # Scaled time z_2 defined with respect to global rho
npk_barCalc    = "'neGlobalMax lc * "+str(c)+" /'"                          # Scaled n_||pk of all beamlets
n_barCalc      = "'ne lc * "+str(c)+" /'"                                   # Scaled n_|| of beamlet
gammaCalc      = "'gammaMean'"                                              # gamma of beamlet
sig_gammaCalc  = "'gammaStDev'"                                             # sigma_gamma of beamlet
x_barCalc      = "'xMean avgx - lc lg * sqrt /'"                            # Scaled x-position of beamlet
y_barCalc      = "'yMean avgy - lc lg * sqrt /'"                            # Scaled y-position of beamlet
px_barCalc     = "'pxMean avgpx - 2 sqrt me * c * aw * /'"                  # Scaled px of beamlet
py_barCalc     = "'pyMean avgpy - 2 sqrt me * c * aw * /'"                  # Scaled py of beamlet


# sig_x_barCalc  = "'xrStDev lc lg * sqrt /'"                                 # Scaled sigma_x of beamlet   # OR "'xStDev lc lg * sqrt /'" for no matching
sig_x_barCalc  = "'xStDev lc lg * sqrt /'"
#sig_x_barCalc = "'emitxnrms rho k_beta / * sqrt'"    # ...if matching beam



#sig_y_barCalc  = "'yrStDev lc lg * sqrt /'"                                 # Scaled sigma_y of beamlet   # OR "'yStDev lc lg * sqrt /'" for no matching
sig_y_barCalc  = "'yStDev lc lg * sqrt /'"
#sig_y_barCalc = "'emitynrms rho k_beta / * sqrt'"    # ...if matching beam


sig_r_barCalc  = "'sig_x_bar sqr sig_y_bar sqr + sqrt'"                     # Scaled sigma_r of beamlet
sig_r_barLCalc = "'xStDev lcL lgL * sqrt / sqr "\
                 +"yStDev lcL lgL * sqrt / sqr + sqrt'"                     # Scaled sigma_r of beamlet (Local scaling)


sig_px_barCalc = "'pxStDev 2 sqrt me * c * aw * /'"                         # Scaled sigma_px of beamlet  # alt  "'pxStDev 2 sqrt me * c * aw * /'"
#sig_px_barCalc = "'eta sqrt emitxnrms * 2 / kappa / sig_x_bar /'"   # ...if matching beam




sig_py_barCalc = "'pyStDev 2 sqrt me * c * aw * /'"                         # Scaled sigma_py of beamlet  # alt  "'pyStDev 2 sqrt me * c * aw * /'"
#sig_py_barCalc = "'eta sqrt emitynrms * 2 / kappa / sig_y_bar /'"   # ...if matching beam

sg_emitCalc    = "'gamma k_beta_barL sig_r_barL * sqr * 4 /'"               # sigma_gamma of beamlet due to emittance 
sg_totCalc     = "'sig_gamma sqr sig_gamma_emit sqr + sqrt'"                # Effective sigma_gamma 
sig_pCalc      = "'sig_gamma_tot gamma / rhoL /'"                           # Local sigma_p of beamlet (Local scaling)
Z_R_barLCalc   = "'rStDev sqr 2 / rhoL / lgL / lcL /'"                      # Scaled Z_R of beamlet (Local scaling)
k_beta_barLCalc= "'aw 2 / f / rhoL / gamma /'"                              # Scaled k_beta of beamlet(Local scaling)
emit_barLCalc  = "'emitnrms gamma / rhoL / lcL /'"                          # Scaled emitance, epsilon-bar of beamlet (Local scaling)
match_testCalc = "'emit_barL 2 / k_beta_barL / Z_R_barL /'"                 # Test for matching - epsilon-bar ~ 2 k_beta_bar Z_R_bar
NeCalc         = "'n_bar Dz2 *'"                                            # Number of electrons in interval Dz2

# Write out the data in SDDS Puffin format
for i in range(0,numb):
    fintp   = fbase+"_"+str(i+1)+".intp";              # Interpolated data in SI units
    fpuf    = fbase+"_"+str(i+1)+".puf1D";             # Interpolated Puffin data in scaled units 
    ipts    = int(sdds.getParameter(fintp,'ipts'))     # Number of interpolation points for beamlet
    Dz2Calc = "'z2Max z2Min - "+str(ipts)+" 1 - /'"    # Spacing in z2 of the interpolated points
    os.system("sddsprocess %s -pipe=output\
           -define=parameter,IoAglobalMax,%e\
           -define=parameter,neGlobalMax,%e\
           -define=parameter,gammaMeanGlobalMin,%e\
           -define=parameter,lambdar,%s\
           -define=parameter,rho,%s\
           -define=parameter,lg,%s\
           -define=parameter,lc,%s\
           -define=parameter,rhoL,%s\
           -define=parameter,lgL,%s\
           -define=parameter,lcL,%s\
           -define=parameter,eta,%s\
           -define=parameter,f,%e\
           -define=parameter,npk_bar,%s\
           -process=tMean,minimum,tmin\
           -define=column,z2,%s,symbol=%s\
           -define=column,gamma,%s,symbol=%s\
           -define=column,sig_gamma,%s,symbol=%s\
           -define=column,n_bar,%s,symbol=%s\
           -define=column,x_bar,%s,symbol=%s\
           -define=column,y_bar,%s,symbol=%s\
           -define=column,sig_x_bar,%s,symbol=%s\
           -define=column,sig_y_bar,%s,symbol=%s\
           -define=column,sig_r_bar,%s,symbol=%s\
           -define=column,sig_r_barL,%s,symbol=%s\
           -define=column,px_bar,%s,symbol=%s\
           -define=column,py_bar,%s,symbol=%s\
           -define=column,sig_px_bar,%s,symbol=%s\
           -define=column,sig_py_bar,%s,symbol=%s\
           -define=column,Z_R_barL,%s,symbol=%s\
           -define=column,k_beta_barL,%s,symbol=%s\
           -define=column,emit_barL,%s,symbol=%s\
           -define=column,sig_gamma_emit,%s,symbol=%s\
           -define=column,sig_gamma_tot,%s,symbol=%s\
           -define=column,sig_p,%s,symbol=%s\
           -define=column,match_test,%s,symbol=%s\
           -process=emitnrms,average,avg_emitnrms,weightBy=I\
           -process=emit_barL,average,avg_emit_barL,weightBy=I\
           -process=k_beta_barL,average,avg_k_beta_barL,weightBy=I\
           -process=Z_R_barL,average,avg_Z_R_barL,weightBy=I\
         |  sddsprocess -pipe=input %s\
           -process=z2,maximum,z2Max\
           -process=z2,minimum,z2Min\
           -define=parameter,Dz2,%s\
           -define=column,Ne,%s\
           -retain=parameters,Dt,aw,lambdaw,avgGamma,ipts,lambdar,lambdarL,Ipk,eta,rho,rhoL,npk_bar\
           -retain=parameters,avg_Z_R_barL,avg_k_beta_barL,avg_emit_barL,avg_emitnrms\
           -retain=columns,z2,gamma,sig_gamma,sig_gamma_emit,sig_gamma_tot,sig_p,n_bar\
           -retain=columns,x_bar,y_bar,sig_x_bar,sig_y_bar,sig_r_bar\
           -retain=columns,px_bar,py_bar,sig_px_bar,sig_py_bar,I"\
           %(fintp,IoAglobalMax,neGlobalMax,gammaMeanGlobalMin,lambdarCalc,\
             rhoCalc,lgCalc,lcCalc,\
             rhoLCalc,lgLCalc,lcLCalc,\
             etaCalc,f,npk_barCalc,\
             z2Calc,z2Sym,\
             gammaCalc,gammaSym,sig_gammaCalc,sig_gammaSym,\
             n_barCalc,n_barSym,\
             x_barCalc,x_barSym,y_barCalc,y_barSym,\
             sig_x_barCalc,sig_x_barSym,sig_y_barCalc,sig_y_barSym,\
             sig_r_barCalc,sig_r_barSym,\
             sig_r_barLCalc,sig_r_barSym,\
             px_barCalc,px_barSym,py_barCalc,py_barSym,\
             sig_px_barCalc,sig_px_barSym,sig_py_barCalc,sig_py_barSym,\
             Z_R_barLCalc,Z_R_barSym,\
             k_beta_barLCalc,k_beta_barSym,\
             emit_barLCalc,emit_barSym,\
             sg_emitCalc,sg_emitSym,\
             sg_totCalc,sg_totSym,sig_pCalc,sig_pSym,\
             match_testCalc,match_testSym,fpuf,Dz2Calc,NeCalc))
    print "Puffin data for beamlet "+str(i+1)+" to                :", fpuf

    fpufa  = fbase+"_"+str(i+1)+".pufin";        # Interpolated Puffin beamlet input file
    os.system("sddsprintout %s %s\
            -parameters='(ipts,Dz2,aw,lambdaw,lambdar,Ipk,eta,rho,npk_bar)'\
            -columns='(z2,gamma,x_bar,y_bar,sig_x_bar,sig_y_bar,px_bar,py_bar,sig_gamma_tot,sig_px_bar,sig_py_bar,Ne)'"\
             %(fpuf,fpufa))
    print "Puffin ascii input data for beamlet "+str(i+1)+" to    :", fpufa

os.system("rm %s" %('*.tmp'))
if os.path.exists('*~'):
   os.system("rm %s" %('*~'))
